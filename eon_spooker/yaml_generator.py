"""
YAML generation functionality for EON-SPOOKER
"""

import logging
from pathlib import Path
from typing import Dict, List, Optional
import yaml

from .config import DEFAULT_OUTPUT_FILES
from .exceptions import FileProcessingError

logger = logging.getLogger(__name__)


class YAMLGenerator:
    """Handles generation of YAML files for Home Assistant"""
    
    def __init__(self, output_dir: Optional[str] = None):
        """
        Initialize YAML generator
        
        Args:
            output_dir: Directory to save YAML files (current directory if None)
        """
        self.output_dir = Path(output_dir) if output_dir else Path.cwd()
        self.output_dir.mkdir(parents=True, exist_ok=True)
    
    def generate_yaml(self, data: List[Dict]) -> str:
        """
        Generate YAML content from time series data
        
        Args:
            data: List of time series data points
            
        Returns:
            YAML string formatted for Home Assistant
        """
        if not data:
            return "# No data available\n[]"
        
        # Convert to Home Assistant statistics format
        ha_stats = self._convert_to_ha_format(data)
        
        # Generate header
        header = f"# Home Assistant statistics data\n"
        header += f"# Generated by EON-SPOOKER v3.0\n"
        header += f"# Data points: {len(ha_stats)}\n"
        header += f"# Format: Home Assistant recorder.import_statistics\n\n"
        
        # Generate YAML
        try:
            yaml_content = yaml.dump(ha_stats, 
                                   default_flow_style=False,
                                   allow_unicode=True,
                                   sort_keys=False,
                                   indent=2)
            return header + yaml_content
        except Exception as e:
            raise FileProcessingError(f"Failed to generate YAML content: {e}")
    
    def generate_multi_resolution_yaml(self, data_dict: Dict[str, List[Dict]]) -> str:
        """
        Generate YAML content for multiple resolutions
        
        Args:
            data_dict: Dictionary with resolution keys and data lists
            
        Returns:
            YAML string with multiple sections
        """
        if not data_dict:
            return "# No data available\n{}"
        
        # Generate header
        header = f"# Home Assistant statistics data - Multiple Resolutions\n"
        header += f"# Generated by EON-SPOOKER v3.0\n"
        header += f"# Available resolutions: {', '.join(data_dict.keys())}\n\n"
        
        # Convert each resolution
        converted_data = {}
        for resolution, data in data_dict.items():
            if data:
                converted_data[resolution] = self._convert_to_ha_format(data)
        
        # Generate YAML
        try:
            yaml_content = yaml.dump(converted_data, 
                                   default_flow_style=False,
                                   allow_unicode=True,
                                   sort_keys=False,
                                   indent=2)
            return header + yaml_content
        except Exception as e:
            raise FileProcessingError(f"Failed to generate multi-resolution YAML: {e}")
    
    def _convert_to_ha_format(self, data: List[Dict]) -> Dict[str, List[Dict]]:
        """
        Convert time series data to Home Assistant statistics format
        
        Args:
            data: List of time series data points
            
        Returns:
            Dictionary with separate import and export statistics
        """
        import_stats = []
        export_stats = []
        
        # Track cumulative totals for incremental data
        cumulative_import = 0.0
        cumulative_export = 0.0
        
        # Sort data by timestamp
        sorted_data = sorted(data, key=lambda x: x.get('datetime', x.get('date')))
        
        for record in sorted_data:
            # Handle different data formats
            if 'datetime' in record:
                timestamp = record['datetime']
            elif 'date' in record:
                timestamp = record['date']
            else:
                continue
            
            # Format timestamp for Home Assistant
            if hasattr(timestamp, 'isoformat'):
                start_time = timestamp.isoformat()
            else:
                start_time = str(timestamp)
            
            # Extract values and handle different data types
            if 'cumulative_import_kwh' in record and 'cumulative_export_kwh' in record:
                # This is already cumulative data (from 180_280 format) - use as-is
                import_value = float(record['cumulative_import_kwh'])
                export_value = float(record['cumulative_export_kwh'])
                
                import_stats.append({
                    'start': start_time,
                    'sum': round(import_value, 3),
                    'state': round(import_value, 3)
                })
                
                export_stats.append({
                    'start': start_time,
                    'sum': round(export_value, 3),
                    'state': round(export_value, 3)
                })
            
            elif 'import_kwh' in record and 'export_kwh' in record:
                # This is incremental data (from AP_AM format) - accumulate
                cumulative_import += float(record['import_kwh'])
                cumulative_export += float(record['export_kwh'])
                
                import_stats.append({
                    'start': start_time,
                    'sum': round(cumulative_import, 3),
                    'state': round(cumulative_import, 3)
                })
                
                export_stats.append({
                    'start': start_time,
                    'sum': round(cumulative_export, 3),
                    'state': round(cumulative_export, 3)
                })
            
            elif 'value_kwh' in record:
                # Legacy format - assume it's already cumulative or add to running total
                value = float(record['value_kwh'])
                variable = record.get('variable', '').lower()
                
                if 'import' in variable or 'bevitel' in variable:
                    cumulative_import += value
                    import_stats.append({
                        'start': start_time,
                        'sum': round(cumulative_import, 3),
                        'state': round(cumulative_import, 3)
                    })
                elif 'export' in variable or 'kiadÃ¡s' in variable:
                    cumulative_export += value
                    export_stats.append({
                        'start': start_time,
                        'sum': round(cumulative_export, 3),
                        'state': round(cumulative_export, 3)
                    })
        
        return {
            'import': import_stats,
            'export': export_stats
        }
    
    def generate_yaml_files(self, processed_data: Dict[str, List[Dict]], 
                          custom_filenames: Optional[Dict[str, str]] = None,
                          backup_existing: bool = True) -> Dict[str, Path]:
        """
        Generate YAML files from processed data
        
        Args:
            processed_data: Processed data from DataProcessor
            custom_filenames: Custom filenames for output files
            backup_existing: Whether to backup existing files
            
        Returns:
            Dictionary mapping data type to output file path
        """
        filenames = custom_filenames or DEFAULT_OUTPUT_FILES
        output_paths = {}
        
        for data_type, data in processed_data.items():
            if data_type not in filenames:
                logger.warning(f"No filename specified for data type: {data_type}")
                continue
            
            filename = filenames[data_type]
            output_path = self.output_dir / filename
            
            # Backup existing file if requested
            if backup_existing and output_path.exists():
                self._backup_file(output_path)
            
            # Generate YAML content
            yaml_content = self._generate_yaml_content(data, data_type)
            
            # Write YAML file
            self._write_yaml_file(output_path, yaml_content)
            
            output_paths[data_type] = output_path
            logger.info(f"Generated {data_type} YAML file: {output_path}")
        
        return output_paths
    
    def _backup_file(self, file_path: Path) -> None:
        """Create a backup of an existing file"""
        backup_path = file_path.with_suffix(f"{file_path.suffix}.backup")
        counter = 1
        
        # Find unique backup filename
        while backup_path.exists():
            backup_path = file_path.with_suffix(f"{file_path.suffix}.backup.{counter}")
            counter += 1
        
        try:
            file_path.rename(backup_path)
            logger.info(f"Backed up existing file to: {backup_path}")
        except Exception as e:
            logger.warning(f"Failed to backup file {file_path}: {e}")
    
    def _generate_yaml_content(self, data: List[Dict], data_type: str) -> str:
        """
        Generate YAML content with proper formatting
        
        Args:
            data: List of data entries
            data_type: Type of data for documentation
            
        Returns:
            Formatted YAML string
        """
        if not data:
            logger.warning(f"No data to generate YAML for {data_type}")
            return "# No data available\n[]"
        
        # Add header comment
        header = f"# Home Assistant statistics data for {data_type}\n"
        header += f"# Generated by EON-SPOOKER\n"
        header += f"# Data points: {len(data)}\n"
        
        # Generate YAML
        try:
            yaml_content = yaml.dump(data, 
                                   default_flow_style=False,
                                   allow_unicode=True,
                                   sort_keys=False,
                                   indent=2)
            return header + yaml_content
        except Exception as e:
            raise FileProcessingError(f"Failed to generate YAML content: {e}")
    
    def _write_yaml_file(self, file_path: Path, content: str) -> None:
        """Write YAML content to file"""
        try:
            with open(file_path, 'w', encoding='utf-8') as file:
                file.write(content)
        except Exception as e:
            raise FileProcessingError(f"Failed to write YAML file {file_path}: {e}")
    
    def generate_home_assistant_example(self, data_type: str, sensor_name: str) -> str:
        """
        Generate example Home Assistant service call
        
        Args:
            data_type: 'import' or 'export'
            sensor_name: Name of the sensor entity
            
        Returns:
            Example YAML service call
        """
        example = f"""# Example Home Assistant service call for {data_type} data
service: recorder.import_statistics
data:
  has_mean: false
  has_sum: true
  statistic_id: {sensor_name}
  source: recorder
  unit_of_measurement: kWh
  stats:
    # Paste the contents of {DEFAULT_OUTPUT_FILES.get(data_type, f'{data_type}.yaml')} here
    # Example entries:
    - start: "2025-06-14 00:00:00+02:00"
      sum: 123.456
      state: 123.456
    - start: "2025-06-14 01:00:00+02:00"
      sum: 124.567
      state: 124.567
"""
        return example
    
    def generate_documentation(self, output_paths: Dict[str, Path], 
                             processed_data: Dict[str, List[Dict]]) -> str:
        """
        Generate documentation for the generated files
        
        Args:
            output_paths: Paths to generated files
            processed_data: The processed data
            
        Returns:
            Documentation string
        """
        doc = "# EON-SPOOKER Output Summary\n\n"
        
        for data_type, file_path in output_paths.items():
            data = processed_data.get(data_type, [])
            doc += f"## {data_type.title()} Data\n"
            doc += f"- File: `{file_path.name}`\n"
            doc += f"- Data points: {len(data)}\n"
            
            if data:
                timestamps = [entry['start'] for entry in data]
                doc += f"- Date range: {timestamps[0]} to {timestamps[-1]}\n"
                
                values = [entry['sum'] for entry in data]
                doc += f"- Value range: {min(values):.3f} - {max(values):.3f} kWh\n"
            
            doc += f"\n### Home Assistant Integration\n"
            doc += f"Use the following service call in Home Assistant:\n\n"
            doc += "```yaml\n"
            doc += self.generate_home_assistant_example(data_type, f"sensor.w1000_{data_type}")
            doc += "```\n\n"
        
        return doc
